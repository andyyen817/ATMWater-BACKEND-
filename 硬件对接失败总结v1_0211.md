# 硬件对接失败总结 v1.0 (2026-02-11)

> **文档目的**：记录TCP硬件对接过程中遇到的所有问题和解决方案，避免重复犯错

---

## 📋 问题时间线

### 初始问题（2026-02-11 06:44）
**现象**：设备连接后约1分钟发送GT命令，收到响应后18秒重启，从未发送AU认证

**日志特征**：
```
[TCP] 🔌 New connection
[TCP] ⬅️ Sent: CONNECT OK
[TCP] ➡️ Received: {"Cmd":"GT",...}GPRS reboot by GPRS_REBOOT!!!
[TCP] ⬅️ Sending response: {...}
[TCP] 🔌 New connection (18秒后，设备重启)
```

---

## ❌ 失败的尝试

### 尝试1：添加时间戳到日志 ✅ 有效但未解决问题
**时间**：2026-02-11 早上
**修改**：给所有TCP日志添加精确时间戳（YYYY-MM-DD HH:mm:ss.SSS）
**结果**：✅ 方便排查，但未解决连接问题
**保留**：是，这个改进很有用

### 尝试2：启用"CONNECT OK"响应 ❌ 无效
**时间**：2026-02-11 早上
**修改**：连接时主动发送"CONNECT OK\n"
**原因**：认为设备期望收到CONNECT OK才会继续
**结果**：❌ 设备还是在GT后重启
**问题**：CONNECT OK是GPRS模块特定格式，不适用于所有设备

### 尝试3：GT命令返回简单"OK"文本 ❌ 无效
**时间**：2026-02-11 上午
**修改**：
```javascript
socket.write('OK\n');
return null;
```
**原因**：认为设备期望简单文本响应
**结果**：❌ 设备还是在18秒后重启

### 尝试4：GT命令返回JSON格式 ❌ 无效
**时间**：2026-02-11 上午
**修改**：
```javascript
return {
  Cmd: 'GT',
  DId: DId,
  PTW: '',
  Type: 'PDF321'
};
```
**原因**：恢复原始JSON响应格式
**结果**：❌ 设备还是在18秒后重启

### 尝试5：移除"CONNECT OK" ❌ 无效
**时间**：2026-02-11 08:52
**修改**：不主动发送CONNECT OK，等待设备发送AU
**原因**：认为CONNECT OK导致设备混淆
**结果**：❌ 设备还是发送GT并重启

---

## ✅ 最终解决方案

### 问题根因
**硬件工程师反馈**："两条命令放到一起处理了，应该是有数据就及时处理。处理了GT命令，就不会引起后面的换socket动作了"

**真相**：
- 设备在**同一个TCP包**中发送了**GT和AU两条命令**
- 旧代码使用 `/^(\{[^}]*\})/` 只提取**第一个JSON对象**
- **AU命令被忽略**，设备认为AU没有响应而重启

### 正确的修复（2026-02-11 09:00+）

**修改前的代码**：
```javascript
// ❌ 只匹配第一个JSON对象
const jsonMatch = cleanMessage.match(/^(\{[^}]*\})/);
if (jsonMatch) {
  cleanMessage = jsonMatch[1];
  // 只处理一个命令
  const cmd = JSON.parse(cleanMessage);
  const response = await handleCommand(cmd, socket);
  // ...
}
```

**修改后的代码**：
```javascript
// ✅ 使用全局匹配提取所有JSON对象
const jsonMatches = cleanMessage.match(/\{[^}]*\}/g);

if (jsonMatches && jsonMatches.length > 0) {
  log(`[TCP] 🧹 Found ${jsonMatches.length} JSON object(s) in message`);

  // ✅ 循环处理每个JSON对象
  for (const jsonStr of jsonMatches) {
    const cmd = JSON.parse(jsonStr);
    const response = await handleCommand(cmd, socket);
    // 发送响应
    // ...
  }
}
```

**关键改进**：
1. 使用全局正则 `/\{[^}]*\}/g` 匹配**所有**JSON对象
2. 循环处理每个命令
3. 每个命令都得到响应

---

## 📊 对比：失败 vs 成功

### 失败的处理流程
```
设备发送: {"Cmd":"GT",...}{"Cmd":"AU",...}
         ↓
服务器提取: {"Cmd":"GT",...}  ← 只提取第一个
         ↓
服务器处理: GT命令
         ↓
服务器响应: GT响应
         ↓
AU命令被忽略 ❌
         ↓
设备等待AU响应超时
         ↓
设备重启 ❌
```

### 成功的处理流程
```
设备发送: {"Cmd":"GT",...}{"Cmd":"AU",...}
         ↓
服务器提取: [{"Cmd":"GT",...}, {"Cmd":"AU",...}]  ← 提取所有
         ↓
服务器处理: GT命令 → GT响应
         ↓
服务器处理: AU命令 → AU响应
         ↓
设备收到两个响应 ✅
         ↓
正常通信 ✅
```

---

## 🎯 关键教训

### 1. 不要假设消息格式
❌ **错误假设**：每条消息只包含一个JSON对象
✅ **正确做法**：使用全局匹配处理所有可能的JSON对象

### 2. 仔细听取硬件工程师的反馈
硬件工程师说"两条命令放到一起处理了"，这是关键线索！
不要忽视这种描述，要深入理解其含义。

### 3. 对比工作的服务器
当硬件工程师说"同样的设备在另一个服务器上正常"时，
说明问题100%在我们的代码上，不是硬件问题。

### 4. 协议文档可能不完整
协议文档没有说明设备会在一个包中发送多个命令，
但实际情况可能与文档不符，要根据实际行为调整。

### 5. 日志要详细
添加时间戳和详细的日志输出非常重要，
帮助我们发现了18秒重启的规律。

---

## 🔧 代码审查清单

在处理TCP硬件通信时，确保：

- [ ] 使用全局正则匹配处理多个JSON对象
- [ ] 循环处理每个命令，不要只处理第一个
- [ ] 每个命令都要发送响应
- [ ] 添加详细的时间戳日志
- [ ] 记录收到的JSON对象数量
- [ ] 处理JSON解析错误，不要让一个错误影响其他命令
- [ ] 测试设备发送多个命令的情况

---

## 📝 正确的JSON提取代码模板

```javascript
// ✅ 正确的多JSON对象处理模板
socket.on('data', async (data) => {
  buffer += data.toString();
  const messages = buffer.split('\n');
  buffer = messages.pop();

  for (const message of messages) {
    if (!message.trim()) continue;

    try {
      // 清理控制字符
      let cleanMessage = message.replace(/[\x00-\x1F\x7F-\x9F]/g, '').trim();

      // ✅ 使用全局匹配提取所有JSON对象
      const jsonMatches = cleanMessage.match(/\{[^}]*\}/g);

      if (jsonMatches && jsonMatches.length > 0) {
        log(`Found ${jsonMatches.length} JSON object(s)`);

        // ✅ 循环处理每个JSON对象
        for (const jsonStr of jsonMatches) {
          try {
            const cmd = JSON.parse(jsonStr);
            const response = await handleCommand(cmd, socket);

            if (response) {
              socket.write(JSON.stringify(response) + '\n');
            }
          } catch (parseError) {
            logError('Failed to parse JSON:', jsonStr);
          }
        }
      }
    } catch (error) {
      logError('Message processing error:', error.message);
    }
  }
});
```

---

## 🚀 后续建议

1. **添加单元测试**
   - 测试单个JSON对象的处理
   - 测试多个JSON对象的处理
   - 测试JSON对象后面有调试信息的情况

2. **添加性能监控**
   - 记录每个命令的处理时间
   - 监控设备重连频率
   - 统计命令类型分布

3. **改进错误处理**
   - 一个JSON解析失败不应影响其他JSON
   - 添加更详细的错误日志
   - 考虑添加错误恢复机制

4. **文档更新**
   - 更新协议文档，说明设备可能发送多个命令
   - 添加常见问题排查指南
   - 记录所有已知的设备行为模式

---

## 📞 联系信息

如果遇到类似问题，请参考本文档。
如有疑问，请联系：
- 后端开发团队
- 硬件工程师团队

---

**文档版本**：v1.0
**创建日期**：2026-02-11
**最后更新**：2026-02-11
**作者**：Claude Sonnet 4.5 + 开发团队
